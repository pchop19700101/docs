import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,f as t}from"./app-CbmXFiL4.js";const e="/assets/image-M_qVeRxY.png",p="/assets/image-1-BJvbn3G9.png",o="/assets/image-2-CE3__WIb.png",c="/assets/image-3-CuiqQsY1.png",i="/assets/image-12-ChpasUM5.png",l="/assets/image-4-CA1VH-Du.png",u="/assets/image-5-Duj5po_w.png",d="/assets/image-6-BE2AG4Zj.png",r="/assets/image-7-BaOuWn-G.png",k="/assets/image-8-JDo_q5C6.png",m="/assets/image-9-B3QGWZTg.png",v="/assets/image-11-CoMdtYYy.png",g="/assets/image-10-DDiJPoI3.png",b="/assets/image-13-vfO65Rlj.png",h="/assets/image-14-Bytdz4iH.png",f="/assets/image-15-zKozGcor.png",x="/assets/image-20-Dj74vVgP.png",y="/assets/image-16-ss56jXux.png",A="/assets/image-17-DHq9-yzg.png",q="/assets/image-18--jY9d5uE.png",R="/assets/image-19-ByS2poYw.png",j={},S=t(`<h1 id="分布式锁" tabindex="-1"><a class="header-anchor" href="#分布式锁"><span>分布式锁</span></a></h1><h2 id="redis" tabindex="-1"><a class="header-anchor" href="#redis"><span>Redis</span></a></h2><h3 id="redis-的-setnx" tabindex="-1"><a class="header-anchor" href="#redis-的-setnx"><span>Redis 的 SETNX</span></a></h3><p>Redis 作为一个公共可访问的地方，正好可以作为“占坑”的地方。</p><p>用 Redis 实现分布式锁的几种方案，我们都是用 SETNX 命令（设置 key 等于某 value）。只是高阶方案传的参数个数不一样，以及考虑了异常情况。</p><p>我们来看下这个命令，<code>SETNX</code>是<code>set If not exist</code>的简写。意思就是当 key 不存在时，设置 key 的值，存在时，什么都不做。</p><p>在 Redis 命令行中是这样执行的：</p><p>我们可以进到 redis 容器中来试下 <code>SETNX</code> 命令。</p><p>先进入容器：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> <span class="token operator">&lt;</span>容器 id<span class="token operator">&gt;</span> redid-cli
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后执行 SETNX 命令：将 <code>wukong</code> 这个 key 对应的 value 设置成 <code>1111</code>。</p><p>返回 <code>OK</code>，表示设置成功。重复执行该命令，返回 <code>nil</code>表示设置失败。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> key value NX
OK
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="青铜方案" tabindex="-1"><a class="header-anchor" href="#青铜方案"><span>青铜方案</span></a></h3><p>先用 Redis 的 SETNX 命令来实现最简单的分布式锁。</p><h4 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h4><p>我们来看下流程图：</p><figure><img src="`+e+`" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><ul><li>多个并发线程都去 Redis 中申请锁，也就是执行 setnx 命令，假设线程 A 执行成功，说明当前线程 A 获得了。</li><li>其他线程执行 setnx 命令都会是失败的，所以需要等待线程 A 释放锁。</li><li>线程 A 执行完自己的业务后，删除锁。</li><li>其他线程继续抢占锁，也就是执行 setnx 命令。因为线程 A 已经删除了锁，所以又有其他线程可以抢占到锁了。</li></ul><p>代码示例如下，Java 中 setnx 命令对应的代码为 <code>setIfAbsent</code>。</p><p>setIfAbsent 方法的第一个参数代表 key，第二个参数代表值。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 1.先抢占锁</span>
<span class="token class-name">Boolean</span> lock <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token string">&quot;lock&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 2.抢占成功，执行业务</span>
  <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TypeEntity</span><span class="token punctuation">&gt;</span></span> typeEntityListFromDb <span class="token operator">=</span> <span class="token function">getDataFromDB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 3.解锁</span>
  redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">&quot;lock&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> typeEntityListFromDb<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// 4.休眠一段时间</span>
  <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 5.抢占失败，等待锁释放</span>
  <span class="token keyword">return</span> <span class="token function">getTypeEntityListByRedisDistributedLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个小问题：那为什么需要休眠一段时间？</p><p>因为该程序存在递归调用，可能会导致栈空间溢出。</p><h4 id="缺陷" tabindex="-1"><a class="header-anchor" href="#缺陷"><span>缺陷</span></a></h4><p>青铜之所以叫青铜，是因为它是最初级的，肯定会带来很多问题。</p><p><strong>设想一种家庭场景</strong>：晚上小空一个人开锁进入了房间，打开了电灯💡，然后突然<code>断电</code>了，小空想开门出去，但是找不到门锁位置，那小明就进不去了，外面的人也进不来。</p><p><img src="`+p+'" alt="Alt text" loading="lazy"> 从技术的角度看：setnx 占锁成功，业务代码出现异常或者服务器宕机，没有执行删除锁的逻辑，就造成了<code>死锁</code>。</p><p><strong>那如何规避这个风险呢？</strong></p><p>设置锁的<code>自动过期时间</code>，过一段时间后，自动删除锁，这样其他线程就能获取到锁了。</p><h3 id="白银方案" tabindex="-1"><a class="header-anchor" href="#白银方案"><span>白银方案</span></a></h3><h4 id="生活中的例子" tabindex="-1"><a class="header-anchor" href="#生活中的例子"><span>生活中的例子</span></a></h4><figure><img src="'+o+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><p>还是生活中的例子：小空开锁成功后，给这款智能锁设置了一个<code>沙漏倒计时⏳</code>，沙漏完后，门锁自动打开。即使房间突然断电，过一段时间后，锁会自动打开，其他人就可以进来了。</p><h4 id="技术原理图" tabindex="-1"><a class="header-anchor" href="#技术原理图"><span>技术原理图</span></a></h4><p>和青铜方案不同的地方在于，在占锁成功后，设置锁的过期时间，这两步是分步执行的。如下图所示：</p><figure><img src="'+c+`" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><h4 id="示例代码" tabindex="-1"><a class="header-anchor" href="#示例代码"><span>示例代码</span></a></h4><p>清理 redis key 的代码如下</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 在 10s 以后，自动清理 lock</span>
redisTemplate<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span><span class="token string">&quot;lock&quot;</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>完整代码如下：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 1.先抢占锁</span>
<span class="token class-name">Boolean</span> lock <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token string">&quot;lock&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 2.在 10s 以后，自动清理 lock</span>
    redisTemplate<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span><span class="token string">&quot;lock&quot;</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 3.抢占成功，执行业务</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TypeEntity</span><span class="token punctuation">&gt;</span></span> typeEntityListFromDb <span class="token operator">=</span> <span class="token function">getDataFromDB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 4.解锁</span>
    redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">&quot;lock&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> typeEntityListFromDb<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="缺陷-1" tabindex="-1"><a class="header-anchor" href="#缺陷-1"><span>缺陷</span></a></h4><p>白银方案看似解决了线程异常或服务器宕机造成的锁未释放的问题，但还是存在其他问题：</p><p>因为占锁和设置过期时间是分两步执行的，所以如果在这两步之间发生了异常，则锁的过期时间根本就没有设置成功。</p><p>所以和青铜方案有一样的问题：<strong>锁永远不能过期</strong>。</p><h3 id="黄金方案" tabindex="-1"><a class="header-anchor" href="#黄金方案"><span>黄金方案</span></a></h3><h4 id="原子指令" tabindex="-1"><a class="header-anchor" href="#原子指令"><span>原子指令</span></a></h4><p>上面的白银方案中，占锁和设置锁过期时间是分步两步执行的，这个时候，我们可以联想到什么：事务的原子性（Atom）。</p><p><strong>原子性</strong>：多条命令要么都成功执行，要么都不执行。</p><p>将两步放在一步中执行：占锁+设置锁过期时间。</p><p>Redis 正好支持这种操作：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 设置某个 key 的值并设置多少毫秒或秒 过期。</span>
<span class="token builtin class-name">set</span> <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>value<span class="token operator">&gt;</span> PX <span class="token operator">&lt;</span>多少毫秒<span class="token operator">&gt;</span> NX
或
<span class="token builtin class-name">set</span> <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>value<span class="token operator">&gt;</span> EX <span class="token operator">&lt;</span>多少秒<span class="token operator">&gt;</span> NX
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后可以通过如下命令查看 key 的变化</p><p>下面演示下如何设置 key 并设置过期时间。注意：执行命令之前需要先删除 key，可以通过客户端或命令删除。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code># 设置 key<span class="token operator">=</span>k，value<span class="token operator">=</span><span class="token number">1111</span>，过期时间<span class="token operator">=</span><span class="token number">5000</span>ms
set k <span class="token number">1111</span> <span class="token constant">PX</span> <span class="token number">5000</span> <span class="token constant">NX</span>
# 查看 key 的状态
ttl k
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行结果如下图所示：每运行一次 <code>ttl</code> 命令，就可以看到 <code>k</code> 的过期时间就会减少。最后会变为 -2（已过期）。</p><figure><img src="`+i+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><h4 id="技术原理图-1" tabindex="-1"><a class="header-anchor" href="#技术原理图-1"><span>技术原理图</span></a></h4><p>黄金方案和白银方案的不同之处：获取锁的时候，也需要设置锁的过期时间，这是一个原子操作，要么都成功执行，要么都不执行。如下图所示：</p><figure><img src="'+l+`" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><h4 id="示例代码-1" tabindex="-1"><a class="header-anchor" href="#示例代码-1"><span>示例代码</span></a></h4><p>设置 <code>lock</code> 的值等于 <code>123</code>，过期时间为 10 秒。如果 <code>10</code> 秒 以后，lock 还存在，则清理 lock。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token string">&quot;lock&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;123&quot;</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="缺陷-2" tabindex="-1"><a class="header-anchor" href="#缺陷-2"><span>缺陷</span></a></h4><p>我们还是举生活中的例子来看下黄金方案的缺陷。</p><ol><li>用户 A 抢占锁</li></ol><figure><img src="`+u+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><ul><li>用户 A 先抢占到了锁，并设置了这个锁 10 秒以后自动开锁，锁的编号为 <code>123</code>。</li><li>10 秒以后，A 还在执行任务，此时锁被自动打开了。</li></ul><ol start="2"><li>用户 B 抢占锁</li></ol><figure><img src="'+d+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><ul><li>用户 B 看到房间的锁打开了，于是抢占到了锁，设置锁的编号为 <code>123</code>，并设置了过期时间 <code>10 秒</code>。</li><li>因房间内只允许一个用户执行任务，所以用户 A 和 用户 B 执行任务<code>产生了冲突</code>。</li><li>用户 A 在 <code>15 s</code> 后，完成了任务，此时 用户 B 还在执行任务。</li><li>用户 A 主动打开了编号为 <code>123</code>的锁。</li><li>用户 B 还在执行任务，发现锁已经被打开了。</li><li>用户 B 非常生气：<strong>我还没执行完任务呢，锁怎么开了？</strong></li></ul><ol start="3"><li>用户 C 抢占锁</li></ol><figure><img src="'+r+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><ul><li>用户 B 的锁被 A 主动打开后，A 离开房间，B 还在执行任务。</li><li>用户 C 抢占到锁，C 开始执行任务。</li><li>因房间内只允许一个用户执行任务，所以用户 B 和 用户 C 执行任务产生了冲突。</li></ul><p>从上面的案例中我们可以知道，因为用户 A 处理任务所需要的时间<strong>大于</strong>锁自动清理（开锁）的时间，所以在自动开锁后，又有其他用户抢占到了锁。当用户 A 完成任务后，会把其他用户抢占到的锁给主动打开。</p><p><strong>这里为什么会打开别人的锁</strong>? 因为锁的编号都叫做 <code>“123”</code>，用户 A 只认锁编号，看见编号为 <code>“123”</code>的锁就开，结果把用户 B 的锁打开了，此时用户 B 还未执行完任务，当然生气了。</p><h3 id="铂金方案" tabindex="-1"><a class="header-anchor" href="#铂金方案"><span>铂金方案</span></a></h3><h4 id="生活中的例子-1" tabindex="-1"><a class="header-anchor" href="#生活中的例子-1"><span>生活中的例子</span></a></h4><p>上面的黄金方案的缺陷也很好解决，给每个锁设置<strong>不同的编号</strong>不就好了～</p><p>如下图所示，B 抢占的锁是蓝色的，和 A 抢占到绿色锁不一样。这样就不会被 A 打开了。</p><figure><img src="'+k+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><h4 id="技术原理图-2" tabindex="-1"><a class="header-anchor" href="#技术原理图-2"><span>技术原理图</span></a></h4><p>与黄金方案的不同之处：</p><ul><li>设置锁的过期时间时，还需要设置唯一编号。</li><li>主动删除锁的时候，需要判断锁的编号是否和设置的一致，如果一致，则认为是自己设置的锁，可以进行主动删除。</li></ul><figure><img src="'+m+`" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><h4 id="代码示例" tabindex="-1"><a class="header-anchor" href="#代码示例"><span>代码示例</span></a></h4><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 1.生成唯一 id</span>
<span class="token class-name">String</span> uuid <span class="token operator">=</span> <span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 2. 抢占锁</span>
<span class="token class-name">Boolean</span> lock <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token string">&quot;lock&quot;</span><span class="token punctuation">,</span> uuid<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;抢占成功：&quot;</span> <span class="token operator">+</span> uuid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 3.抢占成功，执行业务</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TypeEntity</span><span class="token punctuation">&gt;</span></span> typeEntityListFromDb <span class="token operator">=</span> <span class="token function">getDataFromDB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 4.获取当前锁的值</span>
    <span class="token class-name">String</span> lockValue <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;lock&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 5.如果锁的值和设置的值相等，则清理自己的锁</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>lockValue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;清理锁：&quot;</span> <span class="token operator">+</span> lockValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
        redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">&quot;lock&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> typeEntityListFromDb<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;抢占失败，等待锁释放&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 4.休眠一段时间</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 5.抢占失败，等待锁释放</span>
    <span class="token keyword">return</span> <span class="token function">getTypeEntityListByRedisDistributedLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>1.生成随机唯一 id，给锁加上唯一值。</li><li>2.抢占锁，并设置过期时间为 10 s，且锁具有随机唯一 id。</li><li>3.抢占成功，执行业务。</li><li>4.执行完业务后，获取当前锁的值。</li><li>5.如果锁的值和设置的值相等，则清理自己的锁。</li></ul><h4 id="铂金方案的缺陷" tabindex="-1"><a class="header-anchor" href="#铂金方案的缺陷"><span>铂金方案的缺陷</span></a></h4><p>上面的方案看似很完美，但还是存在问题：第 4 步和第 5 步并不是原子性的。</p><figure><img src="`+v+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><ul><li>时刻：0s。线程 A 抢占到了锁。</li><li>时刻：9.5s。线程 A 向 Redis 查询当前 key 的值。</li><li>时刻：10s。锁自动过期。</li><li>时刻：11s。线程 B 抢占到锁。</li><li>时刻：12s。线程 A 在查询途中耗时长，终于拿多锁的值。</li><li>时刻：13s。线程 A 还是拿自己设置的锁的值和返回的值进行比较，值是相等的，清理锁，但是这个锁其实是线程 B 抢占的锁。</li></ul><p>那如何规避这个风险呢？钻石方案登场。</p><h3 id="钻石方案" tabindex="-1"><a class="header-anchor" href="#钻石方案"><span>钻石方案</span></a></h3><p>上面的线程 A 查询锁和删除锁的逻辑不是<code>原子性</code>的，所以将查询锁和删除锁这两步作为原子指令操作就可以了。</p><h4 id="技术原理图-3" tabindex="-1"><a class="header-anchor" href="#技术原理图-3"><span>技术原理图</span></a></h4><p>如下图所示，红色圈出来的部分是钻石方案的不同之处。用脚本进行删除，达到原子操作。</p><figure><img src="'+g+`" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><h4 id="代码示例-1" tabindex="-1"><a class="header-anchor" href="#代码示例-1"><span>代码示例</span></a></h4><p>那如何用脚本进行删除呢？</p><p>我们先来看一下这段 Redis 专属脚本：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&quot;get&quot;</span><span class="token punctuation">,</span><span class="token constant">KEYS</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">ARGV</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
then
    <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&quot;del&quot;</span><span class="token punctuation">,</span><span class="token constant">KEYS</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">else</span>
    <span class="token keyword">return</span> <span class="token number">0</span>
end
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段脚本和铂金方案的获取key，删除key的方式很像。先获取 KEYS[1] 的 value，判断 KEYS[1] 的 value 是否和 ARGV[1] 的值相等，如果相等，则删除 KEYS[1]。</p><p>那么这段脚本怎么在 Java 项目中执行呢？</p><p>分两步：先定义脚本；用 redisTemplate.execute 方法执行脚本。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 脚本解锁</span>
<span class="token class-name">String</span> script <span class="token operator">=</span> <span class="token string">&quot;if redis.call(&#39;get&#39;,KEYS[1]) == ARGV[1] then return redis.call(&#39;del&#39;,KEYS[1]) else return 0 end&quot;</span><span class="token punctuation">;</span>
redisTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DefaultRedisScript</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>script<span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">&quot;lock&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> uuid<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码中，KEYS[1] 对应<code>“lock”</code>，ARGV[1] 对应 <code>“uuid”</code>，含义就是如果 lock 的 value 等于 uuid 则删除 lock。</p><p>而这段 Redis 脚本是由 Redis 内嵌的 Lua 环境执行的，所以又称作 Lua 脚本。</p><p><strong>那钻石方案是不是就完美了呢？有没有更好的方案呢？</strong></p><p>下篇，我们再来介绍另外一种分布式锁的王者方案：Redisson。</p><h2 id="redisson" tabindex="-1"><a class="header-anchor" href="#redisson"><span>Redisson</span></a></h2><h3 id="整合-redisson" tabindex="-1"><a class="header-anchor" href="#整合-redisson"><span>整合 Redisson</span></a></h3><ol><li>引入 Maven 依赖</li></ol><p>pom.xml 引入 redisson的 maven 依赖。</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token comment">&lt;!-- https://mvnrepository.com/artifact/org.redisson/redisson --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.redisson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>redisson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.15.5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>自定义配置类</li></ol><p>下面的代码是单节点 Redis 的配置。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRedissonConfig</span> <span class="token punctuation">{</span>
    <span class="token doc-comment comment">/**
     * 对 Redisson 的使用都是通过 RedissonClient 对象
     * <span class="token keyword">@return</span>
     * <span class="token keyword">@throws</span> <span class="token reference"><span class="token class-name">IOException</span></span>
     */</span>
    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>destroyMethod<span class="token operator">=</span><span class="token string">&quot;shutdown&quot;</span><span class="token punctuation">)</span> <span class="token comment">// 服务停止后调用 shutdown 方法。</span>
    <span class="token keyword">public</span> <span class="token class-name">RedissonClient</span> <span class="token function">redisson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token comment">// 1.创建配置</span>
        <span class="token class-name">Config</span> config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 集群模式</span>
        <span class="token comment">// config.useClusterServers().addNodeAddress(&quot;127.0.0.1:7004&quot;, &quot;127.0.0.1:7001&quot;);</span>
        <span class="token comment">// 2.根据 Config 创建出 RedissonClient 示例。</span>
        config<span class="token punctuation">.</span><span class="token function">useSingleServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token string">&quot;redis://127.0.0.1:6379&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token class-name">Redisson</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="分布式可重入锁" tabindex="-1"><a class="header-anchor" href="#分布式可重入锁"><span>分布式可重入锁</span></a></h3><h4 id="可重入锁测试" tabindex="-1"><a class="header-anchor" href="#可重入锁测试"><span>可重入锁测试</span></a></h4><p>基于Redis的Redisson分布式可重入锁<code>RLock</code>Java 对象实现了<code>java.util.concurrent.locks.Lock</code>接口。同时还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">RLock</span> lock <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">&quot;anyLock&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 最常见的使用方法</span>
lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试下可重入锁的两个点：</p><ul><li>多个线程抢占锁，后面锁需要等待吗？</li><li>如果抢占到锁的线程所在的服务停了，锁会不会被释放？</li></ul><ol><li>验证一：可重入锁是阻塞的吗</li></ol><p>为了验证以上两点，我写了个 demo 程序：代码的流程就是设置<code>WuKong-lock</code>锁，然后加锁，打印线程 ID，等待 10 秒后释放锁，最后返回响应：“test lock ok”。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@ResponseBody</span>
<span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;test-lock&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token class-name">TestLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1.获取锁，只要锁的名字一样，获取到的锁就是同一把锁。</span>
    <span class="token class-name">RLock</span> lock <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">&quot;WuKong-lock&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 2.加锁</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;加锁成功，执行后续代码。线程 ID：&quot;</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//TODO</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 3.解锁</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Finally，释放锁成功。线程 ID：&quot;</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token string">&quot;test lock ok&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>先验证第一个点，用两个 http 请求来测试抢占锁。</p><p>请求的 URL：</p><div class="language-curl line-numbers-mode" data-ext="curl" data-title="curl"><pre class="language-curl"><code>http://localhost:11000/question/v1/redisson/test/test-lock
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+b+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><p>第一个线程对应的线程 ID 为 86，10秒后，释放锁。在这期间，第二个线程需要等待锁释放。</p><p>第一个线程释放锁之后，第二个线程获取到了锁，10 秒后，释放锁。</p><figure><img src="'+h+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><ul><li>第一步：线程 A 在 0 秒时，抢占到锁，0.1 秒后，开始执行等待 10 s。</li><li>第二步：线程 B 在 0.1 秒尝试抢占锁，未能抢到锁（被 A 抢占了）。</li><li>第三步：线程 A 在 10.1 秒后，释放锁。</li><li>第四步：线程 B 在 10.1 秒后抢占到锁，然后等待 10 秒后释放锁。</li></ul><p>由此可以得出结论，Redisson 的可重入锁（lock）是阻塞其他线程的，需要等待其他线程释放的。</p><ol start="2"><li>验证二：服务停了，锁会释放吗？</li></ol><p>如果线程 A 在等待的过程中，服务突然停了，那么锁会释放吗？如果不释放的话，就会成为死锁，阻塞了其他线程获取锁。</p><p>WuKong-lock 有值，而且大家可以看到 TTL 在不断变小，说明 WuKong-lock 是自带过期时间的。</p><p>通过观察，经过 30 秒后，WuKong-lock 过期消失了。说明 Redisson 在停机后，占用的锁会自动释放。</p><p>那这又是什么原理呢？这里就要提一个概念了，<code>看门狗</code>。</p><h4 id="看门狗原理" tabindex="-1"><a class="header-anchor" href="#看门狗原理"><span>看门狗原理</span></a></h4><p>如果负责储存这个分布式锁的 Redisson 节点宕机以后，而且这个锁正好处于锁住的状态时，这个锁会出现锁死的状态。为了避免这种情况的发生，Redisson内部提供了一个监控锁的<code>看门狗</code>，它的作用是在Redisson实例被关闭前，不断的延长锁的有效期。</p><p>默认情况下，看门狗的检查锁的超时时间是30秒钟，也可以通过修改Config.lockWatchdogTimeout来另行指定。</p><p>如果我们未制定 lock 的超时时间，就使用 30 秒作为看门狗的默认时间。只要占锁成功，就会启动一个<code>定时任务</code>：每隔 10 秒重新给锁设置过期的时间，过期时间为 30 秒。</p><figure><img src="'+f+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><p>当服务器宕机后，因为锁的有效期是 30 秒，所以会在 30 秒内自动解锁。（30秒等于宕机之前的锁占用时间+后续锁占用的时间）。</p><p>如下图所示：</p><figure><img src="'+x+`" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><h4 id="设置锁过期时间" tabindex="-1"><a class="header-anchor" href="#设置锁过期时间"><span>设置锁过期时间</span></a></h4><p>我们也可以通过给锁设置过期时间，让其自动解锁。</p><p>如下所示，设置锁 8 秒后自动过期。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果业务执行时间超过 8 秒，手动释放锁将会报错：</p><figure><img src="`+y+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><p>所以我们如果设置了锁的自动过期时间，则执行业务的时间一定要小于锁的自动过期时间，否则就会报错。</p><h3 id="王者方案" tabindex="-1"><a class="header-anchor" href="#王者方案"><span>王者方案</span></a></h3><p>原理图如下：</p><figure><img src="'+A+`" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 1.设置分布式锁</span>
<span class="token class-name">RLock</span> lock <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">&quot;lock&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 2.占用锁</span>
lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 3.执行业务</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token comment">// 4.释放锁</span>
lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>和之前 Redis 的方案相比，简洁很多。</p><p>下面讲解下 Redisson 的其他几种分布式锁，相信大家在以后的项目中也会用到。</p><h3 id="分布式读写锁" tabindex="-1"><a class="header-anchor" href="#分布式读写锁"><span>分布式读写锁</span></a></h3><p>基于 Redis 的 Redisson 分布式可重入读写锁<code>RReadWriteLock</code> Java对象实现了<code>java.util.concurrent.locks.ReadWriteLock</code>接口。其中读锁和写锁都继承了 <code>RLock</code>接口。</p><p>写锁是一个排他锁（互斥锁），读锁是一个共享锁。</p><ul><li>读锁 + 读锁：相当于没加锁，可以并发读。</li><li>读锁 + 写锁：写锁需要等待读锁释放锁。</li><li>写锁 + 写锁：互斥，需要等待对方的锁释放。</li><li>写锁 + 读锁：读锁需要等待写锁释放。</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">RReadWriteLock</span> rwlock <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getReadWriteLock</span><span class="token punctuation">(</span><span class="token string">&quot;anyRWLock&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 最常见的使用方法</span>
rwlock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 或</span>
rwlock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外Redisson还通过加锁的方法提供了<code>leaseTime</code>的参数来指定加锁的时间。超过这个时间后锁便自动解开了。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 10秒钟以后自动解锁</span>
<span class="token comment">// 无需调用unlock方法手动解锁</span>
rwlock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 或</span>
rwlock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span>
<span class="token keyword">boolean</span> res <span class="token operator">=</span> rwlock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 或</span>
<span class="token keyword">boolean</span> res <span class="token operator">=</span> rwlock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="分布式信号量" tabindex="-1"><a class="header-anchor" href="#分布式信号量"><span>分布式信号量</span></a></h3><p>基于Redis的Redisson的分布式信号量（Semaphore）Java对象<code>RSemaphore</code>采用了与<code>java.util.concurrent.Semaphore</code>相似的接口和用法。同时还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p><p>关于信号量的使用大家可以想象一下这个场景，有三个停车位，当三个停车位满了后，其他车就不停了。可以把车位比作信号，现在有三个信号，停一次车，用掉一个信号，车离开就是释放一个信号。</p><p>先定义一个占用停车位的方法：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
* 停车，占用停车位
* 总共 3 个车位
*/</span>
<span class="token annotation punctuation">@ResponseBody</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;park&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取信号量（停车场）</span>
  <span class="token class-name">RSemaphore</span> park <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getSemaphore</span><span class="token punctuation">(</span><span class="token string">&quot;park&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 获取一个信号（停车位）</span>
  park<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token string">&quot;OK&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再定义一个离开车位的方法：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 释放车位
 * 总共 3 个车位
 */</span>
<span class="token annotation punctuation">@ResponseBody</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;leave&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">leave</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取信号量（停车场）</span>
    <span class="token class-name">RSemaphore</span> park <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getSemaphore</span><span class="token punctuation">(</span><span class="token string">&quot;park&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 释放一个信号（停车位）</span>
    park<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token string">&quot;OK&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了简便，我用 Redis 客户端添加了一个 key：“park”，值等于 3，代表信号量为 park，总共有三个值。</p><figure><img src="`+q+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><p>然后用 postman 发送 park 请求占用一个停车位。</p><figure><img src="'+R+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><p>然后在 redis 客户端查看 park 的值，发现已经改为 2 了。继续调用两次，发现 park 的等于 0，当调用第四次的时候，会发现请求一直处于<code>等待中</code>，说明车位不够了。如果想要不阻塞，可以用 tryAcquire 或 tryAcquireAsync。</p><p>我们再调用离开车位的方法，park 的值变为了 1，代表车位剩余 1 个。</p><p><strong>注意</strong>：多次执行释放信号量操作，剩余信号量会一直增加，而不是到 3 后就封顶了。</p><p>其他分布式锁：</p><ul><li>公平锁（Fair Lock）</li><li>联锁（MultiLock）</li><li>红锁（RedLock）</li><li>读写锁（ReadWriteLock）</li><li>可过期性信号量（PermitExpirableSemaphore）</li><li>闭锁（CountDownLatch）</li></ul>',186),_=[S];function w(T,L){return s(),a("div",null,_)}const B=n(j,[["render",w],["__file","distributed-lock.html.vue"]]),N=JSON.parse('{"path":"/question/distributed-system/distributed-lock.html","title":"分布式锁","lang":"en-US","frontmatter":{"description":"分布式锁 Redis Redis 的 SETNX Redis 作为一个公共可访问的地方，正好可以作为“占坑”的地方。 用 Redis 实现分布式锁的几种方案，我们都是用 SETNX 命令（设置 key 等于某 value）。只是高阶方案传的参数个数不一样，以及考虑了异常情况。 我们来看下这个命令，SETNX是set If not exist的简写。意思...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/question/distributed-system/distributed-lock.html"}],["meta",{"property":"og:site_name","content":"Docs Demo"}],["meta",{"property":"og:title","content":"分布式锁"}],["meta",{"property":"og:description","content":"分布式锁 Redis Redis 的 SETNX Redis 作为一个公共可访问的地方，正好可以作为“占坑”的地方。 用 Redis 实现分布式锁的几种方案，我们都是用 SETNX 命令（设置 key 等于某 value）。只是高阶方案传的参数个数不一样，以及考虑了异常情况。 我们来看下这个命令，SETNX是set If not exist的简写。意思..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-04-20T02:59:58.000Z"}],["meta",{"property":"article:author","content":"NULL"}],["meta",{"property":"article:modified_time","content":"2024-04-20T02:59:58.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"分布式锁\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-20T02:59:58.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"NULL\\"}]}"]]},"headers":[{"level":2,"title":"Redis","slug":"redis","link":"#redis","children":[{"level":3,"title":"Redis 的 SETNX","slug":"redis-的-setnx","link":"#redis-的-setnx","children":[]},{"level":3,"title":"青铜方案","slug":"青铜方案","link":"#青铜方案","children":[{"level":4,"title":"原理","slug":"原理","link":"#原理","children":[]},{"level":4,"title":"缺陷","slug":"缺陷","link":"#缺陷","children":[]}]},{"level":3,"title":"白银方案","slug":"白银方案","link":"#白银方案","children":[{"level":4,"title":"生活中的例子","slug":"生活中的例子","link":"#生活中的例子","children":[]},{"level":4,"title":"技术原理图","slug":"技术原理图","link":"#技术原理图","children":[]},{"level":4,"title":"示例代码","slug":"示例代码","link":"#示例代码","children":[]},{"level":4,"title":"缺陷","slug":"缺陷-1","link":"#缺陷-1","children":[]}]},{"level":3,"title":"黄金方案","slug":"黄金方案","link":"#黄金方案","children":[{"level":4,"title":"原子指令","slug":"原子指令","link":"#原子指令","children":[]},{"level":4,"title":"技术原理图","slug":"技术原理图-1","link":"#技术原理图-1","children":[]},{"level":4,"title":"示例代码","slug":"示例代码-1","link":"#示例代码-1","children":[]},{"level":4,"title":"缺陷","slug":"缺陷-2","link":"#缺陷-2","children":[]}]},{"level":3,"title":"铂金方案","slug":"铂金方案","link":"#铂金方案","children":[{"level":4,"title":"生活中的例子","slug":"生活中的例子-1","link":"#生活中的例子-1","children":[]},{"level":4,"title":"技术原理图","slug":"技术原理图-2","link":"#技术原理图-2","children":[]},{"level":4,"title":"代码示例","slug":"代码示例","link":"#代码示例","children":[]},{"level":4,"title":"铂金方案的缺陷","slug":"铂金方案的缺陷","link":"#铂金方案的缺陷","children":[]}]},{"level":3,"title":"钻石方案","slug":"钻石方案","link":"#钻石方案","children":[{"level":4,"title":"技术原理图","slug":"技术原理图-3","link":"#技术原理图-3","children":[]},{"level":4,"title":"代码示例","slug":"代码示例-1","link":"#代码示例-1","children":[]}]}]},{"level":2,"title":"Redisson","slug":"redisson","link":"#redisson","children":[{"level":3,"title":"整合 Redisson","slug":"整合-redisson","link":"#整合-redisson","children":[]},{"level":3,"title":"分布式可重入锁","slug":"分布式可重入锁","link":"#分布式可重入锁","children":[{"level":4,"title":"可重入锁测试","slug":"可重入锁测试","link":"#可重入锁测试","children":[]},{"level":4,"title":"看门狗原理","slug":"看门狗原理","link":"#看门狗原理","children":[]},{"level":4,"title":"设置锁过期时间","slug":"设置锁过期时间","link":"#设置锁过期时间","children":[]}]},{"level":3,"title":"王者方案","slug":"王者方案","link":"#王者方案","children":[]},{"level":3,"title":"分布式读写锁","slug":"分布式读写锁","link":"#分布式读写锁","children":[]},{"level":3,"title":"分布式信号量","slug":"分布式信号量","link":"#分布式信号量","children":[]}]}],"git":{"createdTime":1712827443000,"updatedTime":1713581998000,"contributors":[{"name":"null","email":"null","commits":6}]},"readingTime":{"minutes":15.86,"words":4757},"filePathRelative":"question/distributed-system/distributed-lock.md","localizedDate":"April 11, 2024","autoDesc":true}');export{B as comp,N as data};
