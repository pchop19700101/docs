import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,f as t}from"./app-Ig1UFzyf.js";const e="/assets/image-M_qVeRxY.png",p="/assets/image-1-BJvbn3G9.png",o="/assets/image-2-CE3__WIb.png",i="/assets/image-3-CuiqQsY1.png",l="/assets/image-12-ChpasUM5.png",c="/assets/image-4-CA1VH-Du.png",u="/assets/image-5-Duj5po_w.png",d="/assets/image-6-BE2AG4Zj.png",r="/assets/image-7-BaOuWn-G.png",k="/assets/image-8-JDo_q5C6.png",m="/assets/image-9-B3QGWZTg.png",v="/assets/image-11-CoMdtYYy.png",g="/assets/image-10-DDiJPoI3.png",h={},b=t(`<h1 id="custom-id" tabindex="-1"><a class="header-anchor" href="#custom-id"><span>Redis</span></a></h1><h2 id="redis-的-setnx" tabindex="-1"><a class="header-anchor" href="#redis-的-setnx"><span>Redis 的 SETNX</span></a></h2><p>Redis 作为一个公共可访问的地方，正好可以作为“占坑”的地方。</p><p>用 Redis 实现分布式锁的几种方案，我们都是用 SETNX 命令（设置 key 等于某 value）。只是高阶方案传的参数个数不一样，以及考虑了异常情况。</p><p>我们来看下这个命令，<code>SETNX</code>是<code>set If not exist</code>的简写。意思就是当 key 不存在时，设置 key 的值，存在时，什么都不做。</p><p>在 Redis 命令行中是这样执行的：</p><p>我们可以进到 redis 容器中来试下 <code>SETNX</code> 命令。</p><p>先进入容器：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> <span class="token operator">&lt;</span>容器 id<span class="token operator">&gt;</span> redid-cli
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后执行 SETNX 命令：将 <code>wukong</code> 这个 key 对应的 value 设置成 <code>1111</code>。</p><p>返回 <code>OK</code>，表示设置成功。重复执行该命令，返回 <code>nil</code>表示设置失败。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> key value NX
OK
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="青铜方案" tabindex="-1"><a class="header-anchor" href="#青铜方案"><span>青铜方案</span></a></h2><p>先用 Redis 的 SETNX 命令来实现最简单的分布式锁。</p><h3 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h3><p>我们来看下流程图：</p><figure><img src="`+e+`" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><ul><li>多个并发线程都去 Redis 中申请锁，也就是执行 setnx 命令，假设线程 A 执行成功，说明当前线程 A 获得了。</li><li>其他线程执行 setnx 命令都会是失败的，所以需要等待线程 A 释放锁。</li><li>线程 A 执行完自己的业务后，删除锁。</li><li>其他线程继续抢占锁，也就是执行 setnx 命令。因为线程 A 已经删除了锁，所以又有其他线程可以抢占到锁了。</li></ul><p>代码示例如下，Java 中 setnx 命令对应的代码为 <code>setIfAbsent</code>。</p><p>setIfAbsent 方法的第一个参数代表 key，第二个参数代表值。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 1.先抢占锁</span>
<span class="token class-name">Boolean</span> lock <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token string">&quot;lock&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 2.抢占成功，执行业务</span>
  <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TypeEntity</span><span class="token punctuation">&gt;</span></span> typeEntityListFromDb <span class="token operator">=</span> <span class="token function">getDataFromDB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 3.解锁</span>
  redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">&quot;lock&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> typeEntityListFromDb<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// 4.休眠一段时间</span>
  <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 5.抢占失败，等待锁释放</span>
  <span class="token keyword">return</span> <span class="token function">getTypeEntityListByRedisDistributedLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个小问题：那为什么需要休眠一段时间？</p><p>因为该程序存在递归调用，可能会导致栈空间溢出。</p><h3 id="缺陷" tabindex="-1"><a class="header-anchor" href="#缺陷"><span>缺陷</span></a></h3><p>青铜之所以叫青铜，是因为它是最初级的，肯定会带来很多问题。</p><p><strong>设想一种家庭场景</strong>：晚上小空一个人开锁进入了房间，打开了电灯💡，然后突然<code>断电</code>了，小空想开门出去，但是找不到门锁位置，那小明就进不去了，外面的人也进不来。</p><p><img src="`+p+'" alt="Alt text" loading="lazy"> 从技术的角度看：setnx 占锁成功，业务代码出现异常或者服务器宕机，没有执行删除锁的逻辑，就造成了<code>死锁</code>。</p><p><strong>那如何规避这个风险呢？</strong></p><p>设置锁的<code>自动过期时间</code>，过一段时间后，自动删除锁，这样其他线程就能获取到锁了。</p><h2 id="白银方案" tabindex="-1"><a class="header-anchor" href="#白银方案"><span>白银方案</span></a></h2><h3 id="生活中的例子" tabindex="-1"><a class="header-anchor" href="#生活中的例子"><span>生活中的例子</span></a></h3><figure><img src="'+o+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><p>还是生活中的例子：小空开锁成功后，给这款智能锁设置了一个<code>沙漏倒计时⏳</code>，沙漏完后，门锁自动打开。即使房间突然断电，过一段时间后，锁会自动打开，其他人就可以进来了。</p><h3 id="技术原理图" tabindex="-1"><a class="header-anchor" href="#技术原理图"><span>技术原理图</span></a></h3><p>和青铜方案不同的地方在于，在占锁成功后，设置锁的过期时间，这两步是分步执行的。如下图所示：</p><figure><img src="'+i+`" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><h3 id="示例代码" tabindex="-1"><a class="header-anchor" href="#示例代码"><span>示例代码</span></a></h3><p>清理 redis key 的代码如下</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 在 10s 以后，自动清理 lock</span>
redisTemplate<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span><span class="token string">&quot;lock&quot;</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>完整代码如下：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 1.先抢占锁</span>
<span class="token class-name">Boolean</span> lock <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token string">&quot;lock&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 2.在 10s 以后，自动清理 lock</span>
    redisTemplate<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span><span class="token string">&quot;lock&quot;</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 3.抢占成功，执行业务</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TypeEntity</span><span class="token punctuation">&gt;</span></span> typeEntityListFromDb <span class="token operator">=</span> <span class="token function">getDataFromDB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 4.解锁</span>
    redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">&quot;lock&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> typeEntityListFromDb<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="缺陷-1" tabindex="-1"><a class="header-anchor" href="#缺陷-1"><span>缺陷</span></a></h3><p>白银方案看似解决了线程异常或服务器宕机造成的锁未释放的问题，但还是存在其他问题：</p><p>因为占锁和设置过期时间是分两步执行的，所以如果在这两步之间发生了异常，则锁的过期时间根本就没有设置成功。</p><p>所以和青铜方案有一样的问题：<strong>锁永远不能过期</strong>。</p><h2 id="黄金方案" tabindex="-1"><a class="header-anchor" href="#黄金方案"><span>黄金方案</span></a></h2><h3 id="原子指令" tabindex="-1"><a class="header-anchor" href="#原子指令"><span>原子指令</span></a></h3><p>上面的白银方案中，占锁和设置锁过期时间是分步两步执行的，这个时候，我们可以联想到什么：事务的原子性（Atom）。</p><p><strong>原子性</strong>：多条命令要么都成功执行，要么都不执行。</p><p>将两步放在一步中执行：占锁+设置锁过期时间。</p><p>Redis 正好支持这种操作：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 设置某个 key 的值并设置多少毫秒或秒 过期。</span>
<span class="token builtin class-name">set</span> <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>value<span class="token operator">&gt;</span> PX <span class="token operator">&lt;</span>多少毫秒<span class="token operator">&gt;</span> NX
或
<span class="token builtin class-name">set</span> <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>value<span class="token operator">&gt;</span> EX <span class="token operator">&lt;</span>多少秒<span class="token operator">&gt;</span> NX
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后可以通过如下命令查看 key 的变化</p><p>下面演示下如何设置 key 并设置过期时间。注意：执行命令之前需要先删除 key，可以通过客户端或命令删除。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code># 设置 key<span class="token operator">=</span>k，value<span class="token operator">=</span><span class="token number">1111</span>，过期时间<span class="token operator">=</span>5000ms
<span class="token keyword">set</span> k <span class="token number">1111</span> <span class="token constant">PX</span> <span class="token number">5000</span> <span class="token constant">NX</span>
# 查看 key 的状态
ttl k
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行结果如下图所示：每运行一次 <code>ttl</code> 命令，就可以看到 <code>k</code> 的过期时间就会减少。最后会变为 -2（已过期）。</p><figure><img src="`+l+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><h3 id="技术原理图-1" tabindex="-1"><a class="header-anchor" href="#技术原理图-1"><span>技术原理图</span></a></h3><p>黄金方案和白银方案的不同之处：获取锁的时候，也需要设置锁的过期时间，这是一个原子操作，要么都成功执行，要么都不执行。如下图所示：</p><figure><img src="'+c+`" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><h3 id="示例代码-1" tabindex="-1"><a class="header-anchor" href="#示例代码-1"><span>示例代码</span></a></h3><p>设置 <code>lock</code> 的值等于 <code>123</code>，过期时间为 10 秒。如果 <code>10</code> 秒 以后，lock 还存在，则清理 lock。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token string">&quot;lock&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;123&quot;</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="缺陷-2" tabindex="-1"><a class="header-anchor" href="#缺陷-2"><span>缺陷</span></a></h3><p>我们还是举生活中的例子来看下黄金方案的缺陷。</p><ol><li>用户 A 抢占锁</li></ol><figure><img src="`+u+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><ul><li>用户 A 先抢占到了锁，并设置了这个锁 10 秒以后自动开锁，锁的编号为 <code>123</code>。</li><li>10 秒以后，A 还在执行任务，此时锁被自动打开了。</li></ul><ol start="2"><li>用户 B 抢占锁</li></ol><figure><img src="'+d+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><ul><li>用户 B 看到房间的锁打开了，于是抢占到了锁，设置锁的编号为 <code>123</code>，并设置了过期时间 <code>10 秒</code>。</li><li>因房间内只允许一个用户执行任务，所以用户 A 和 用户 B 执行任务<code>产生了冲突</code>。</li><li>用户 A 在 <code>15 s</code> 后，完成了任务，此时 用户 B 还在执行任务。</li><li>用户 A 主动打开了编号为 <code>123</code>的锁。</li><li>用户 B 还在执行任务，发现锁已经被打开了。</li><li>用户 B 非常生气：<strong>我还没执行完任务呢，锁怎么开了？</strong></li></ul><ol start="3"><li>用户 C 抢占锁</li></ol><figure><img src="'+r+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><ul><li>用户 B 的锁被 A 主动打开后，A 离开房间，B 还在执行任务。</li><li>用户 C 抢占到锁，C 开始执行任务。</li><li>因房间内只允许一个用户执行任务，所以用户 B 和 用户 C 执行任务产生了冲突。</li></ul><p>从上面的案例中我们可以知道，因为用户 A 处理任务所需要的时间<strong>大于</strong>锁自动清理（开锁）的时间，所以在自动开锁后，又有其他用户抢占到了锁。当用户 A 完成任务后，会把其他用户抢占到的锁给主动打开。</p><p><strong>这里为什么会打开别人的锁</strong>?因为锁的编号都叫做 <code>“123”</code>，用户 A 只认锁编号，看见编号为 <code>“123”</code>的锁就开，结果把用户 B 的锁打开了，此时用户 B 还未执行完任务，当然生气了。</p><h2 id="铂金方案" tabindex="-1"><a class="header-anchor" href="#铂金方案"><span>铂金方案</span></a></h2><h4 id="_6-1-生活中的例子" tabindex="-1"><a class="header-anchor" href="#_6-1-生活中的例子"><span><strong>6.1 生活中的例子</strong></span></a></h4><p>上面的黄金方案的缺陷也很好解决，给每个锁设置<strong>不同的编号</strong>不就好了～</p><p>如下图所示，B 抢占的锁是蓝色的，和 A 抢占到绿色锁不一样。这样就不会被 A 打开了。</p><figure><img src="'+k+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><h3 id="技术原理图-2" tabindex="-1"><a class="header-anchor" href="#技术原理图-2"><span>技术原理图</span></a></h3><p>与黄金方案的不同之处：</p><ul><li>设置锁的过期时间时，还需要设置唯一编号。</li><li>主动删除锁的时候，需要判断锁的编号是否和设置的一致，如果一致，则认为是自己设置的锁，可以进行主动删除。</li></ul><figure><img src="'+m+`" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><h4 id="_6-3-代码示例" tabindex="-1"><a class="header-anchor" href="#_6-3-代码示例"><span><strong>6.3 代码示例</strong></span></a></h4><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 1.生成唯一 id</span>
<span class="token class-name">String</span> uuid <span class="token operator">=</span> <span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 2. 抢占锁</span>
<span class="token class-name">Boolean</span> lock <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token string">&quot;lock&quot;</span><span class="token punctuation">,</span> uuid<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;抢占成功：&quot;</span> <span class="token operator">+</span> uuid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 3.抢占成功，执行业务</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TypeEntity</span><span class="token punctuation">&gt;</span></span> typeEntityListFromDb <span class="token operator">=</span> <span class="token function">getDataFromDB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 4.获取当前锁的值</span>
    <span class="token class-name">String</span> lockValue <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;lock&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 5.如果锁的值和设置的值相等，则清理自己的锁</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>lockValue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;清理锁：&quot;</span> <span class="token operator">+</span> lockValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
        redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">&quot;lock&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> typeEntityListFromDb<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;抢占失败，等待锁释放&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 4.休眠一段时间</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 5.抢占失败，等待锁释放</span>
    <span class="token keyword">return</span> <span class="token function">getTypeEntityListByRedisDistributedLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>1.生成随机唯一 id，给锁加上唯一值。</li><li>2.抢占锁，并设置过期时间为 10 s，且锁具有随机唯一 id。</li><li>3.抢占成功，执行业务。</li><li>4.执行完业务后，获取当前锁的值。</li><li>5.如果锁的值和设置的值相等，则清理自己的锁。</li></ul><h4 id="_6-4-铂金方案的缺陷" tabindex="-1"><a class="header-anchor" href="#_6-4-铂金方案的缺陷"><span><strong>6.4 铂金方案的缺陷</strong></span></a></h4><p>上面的方案看似很完美，但还是存在问题：第 4 步和第 5 步并不是原子性的。</p><figure><img src="`+v+'" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><ul><li>时刻：0s。线程 A 抢占到了锁。</li><li>时刻：9.5s。线程 A 向 Redis 查询当前 key 的值。</li><li>时刻：10s。锁自动过期。</li><li>时刻：11s。线程 B 抢占到锁。</li><li>时刻：12s。线程 A 在查询途中耗时长，终于拿多锁的值。</li><li>时刻：13s。线程 A 还是拿自己设置的锁的值和返回的值进行比较，值是相等的，清理锁，但是这个锁其实是线程 B 抢占的锁。</li></ul><p>那如何规避这个风险呢？钻石方案登场。</p><h2 id="钻石方案" tabindex="-1"><a class="header-anchor" href="#钻石方案"><span>钻石方案</span></a></h2><p>上面的线程 A 查询锁和删除锁的逻辑不是<code>原子性</code>的，所以将查询锁和删除锁这两步作为原子指令操作就可以了。</p><h3 id="技术原理图-3" tabindex="-1"><a class="header-anchor" href="#技术原理图-3"><span>技术原理图</span></a></h3><p>如下图所示，红色圈出来的部分是钻石方案的不同之处。用脚本进行删除，达到原子操作。</p><figure><img src="'+g+`" alt="Alt text" tabindex="0" loading="lazy"><figcaption>Alt text</figcaption></figure><h3 id="代码示例" tabindex="-1"><a class="header-anchor" href="#代码示例"><span>代码示例</span></a></h3><p>那如何用脚本进行删除呢？</p><p>我们先来看一下这段 Redis 专属脚本：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&quot;get&quot;</span><span class="token punctuation">,</span><span class="token constant">KEYS</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">ARGV</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
then
    <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&quot;del&quot;</span><span class="token punctuation">,</span><span class="token constant">KEYS</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">else</span>
    <span class="token keyword">return</span> <span class="token number">0</span>
end
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段脚本和铂金方案的获取key，删除key的方式很像。先获取 KEYS[1] 的 value，判断 KEYS[1] 的 value 是否和 ARGV[1] 的值相等，如果相等，则删除 KEYS[1]。</p><p>那么这段脚本怎么在 Java 项目中执行呢？</p><p>分两步：先定义脚本；用 redisTemplate.execute 方法执行脚本。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 脚本解锁</span>
<span class="token class-name">String</span> script <span class="token operator">=</span> <span class="token string">&quot;if redis.call(&#39;get&#39;,KEYS[1]) == ARGV[1] then return redis.call(&#39;del&#39;,KEYS[1]) else return 0 end&quot;</span><span class="token punctuation">;</span>
redisTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DefaultRedisScript</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>script<span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">&quot;lock&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> uuid<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码中，KEYS[1] 对应<code>“lock”</code>，ARGV[1] 对应 <code>“uuid”</code>，含义就是如果 lock 的 value 等于 uuid 则删除 lock。</p><p>而这段 Redis 脚本是由 Redis 内嵌的 Lua 环境执行的，所以又称作 Lua 脚本。</p><p><strong>那钻石方案是不是就完美了呢？有没有更好的方案呢？</strong></p><p>下篇，我们再来介绍另外一种分布式锁的王者方案：Redisson。</p>`,110),f=[b];function y(x,A){return s(),a("div",null,f)}const S=n(h,[["render",y],["__file","distributed-lock.html.vue"]]),E=JSON.parse('{"path":"/question/distributed-system/distributed-lock.html","title":"分布式锁","lang":"en-US","frontmatter":{"title":"分布式锁","description":"Redis Redis 的 SETNX Redis 作为一个公共可访问的地方，正好可以作为“占坑”的地方。 用 Redis 实现分布式锁的几种方案，我们都是用 SETNX 命令（设置 key 等于某 value）。只是高阶方案传的参数个数不一样，以及考虑了异常情况。 我们来看下这个命令，SETNX是set If not exist的简写。意思就是当 k...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/./question/distributed-system/distributed-lock.html"}],["meta",{"property":"og:site_name","content":"Docs Demo"}],["meta",{"property":"og:title","content":"分布式锁"}],["meta",{"property":"og:description","content":"Redis Redis 的 SETNX Redis 作为一个公共可访问的地方，正好可以作为“占坑”的地方。 用 Redis 实现分布式锁的几种方案，我们都是用 SETNX 命令（设置 key 等于某 value）。只是高阶方案传的参数个数不一样，以及考虑了异常情况。 我们来看下这个命令，SETNX是set If not exist的简写。意思就是当 k..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-04-11T11:17:44.000Z"}],["meta",{"property":"article:author","content":"NULL"}],["meta",{"property":"article:modified_time","content":"2024-04-11T11:17:44.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"分布式锁\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-11T11:17:44.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"NULL\\"}]}"]]},"headers":[{"level":2,"title":"Redis 的 SETNX","slug":"redis-的-setnx","link":"#redis-的-setnx","children":[]},{"level":2,"title":"青铜方案","slug":"青铜方案","link":"#青铜方案","children":[{"level":3,"title":"原理","slug":"原理","link":"#原理","children":[]},{"level":3,"title":"缺陷","slug":"缺陷","link":"#缺陷","children":[]}]},{"level":2,"title":"白银方案","slug":"白银方案","link":"#白银方案","children":[{"level":3,"title":"生活中的例子","slug":"生活中的例子","link":"#生活中的例子","children":[]},{"level":3,"title":"技术原理图","slug":"技术原理图","link":"#技术原理图","children":[]},{"level":3,"title":"示例代码","slug":"示例代码","link":"#示例代码","children":[]},{"level":3,"title":"缺陷","slug":"缺陷-1","link":"#缺陷-1","children":[]}]},{"level":2,"title":"黄金方案","slug":"黄金方案","link":"#黄金方案","children":[{"level":3,"title":"原子指令","slug":"原子指令","link":"#原子指令","children":[]},{"level":3,"title":"技术原理图","slug":"技术原理图-1","link":"#技术原理图-1","children":[]},{"level":3,"title":"示例代码","slug":"示例代码-1","link":"#示例代码-1","children":[]},{"level":3,"title":"缺陷","slug":"缺陷-2","link":"#缺陷-2","children":[]}]},{"level":2,"title":"铂金方案","slug":"铂金方案","link":"#铂金方案","children":[{"level":3,"title":"技术原理图","slug":"技术原理图-2","link":"#技术原理图-2","children":[]}]},{"level":2,"title":"钻石方案","slug":"钻石方案","link":"#钻石方案","children":[{"level":3,"title":"技术原理图","slug":"技术原理图-3","link":"#技术原理图-3","children":[]},{"level":3,"title":"代码示例","slug":"代码示例","link":"#代码示例","children":[]}]}],"git":{"createdTime":1712827443000,"updatedTime":1712834264000,"contributors":[{"name":"null","email":"null","commits":2}]},"readingTime":{"minutes":9.31,"words":2793},"filePathRelative":"question/distributed-system/distributed-lock.md","localizedDate":"April 11, 2024","autoDesc":true}');export{S as comp,E as data};
